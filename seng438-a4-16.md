**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 â€“ Mutation Testing and Web app testing**

| Group \#:      | 16                        |
| -------------- | ------------------------- |
| Student Names: | Dominic Choi              |
|                | Angelo Jerome T. Reynante |
|                | Nathan Ante               |
|                | Karam Baroud              |


# Introduction


# Analysis of 10 Mutants of the Range class 
| Mutation Number | Method | Mutation | Killed/Survived | How the Mutation Was Killed or Not by Original Test Suite |
|-----------------|--------|----------|--------|-----------------------------------------------------------|
| 1               | getUpperBound | Incremented (a++) double field upper | SURVIVED | Survived because we need to try calling getUpperBound 2 times in a row |
| 2               | getUpperBound | Incremented (++a) double field upper | KILLED | Killed because operator is pre-increment and change to upper is immediate |
| 3               | getLowerBound | Incremented (a++) double field lower | SURVIVED | Survived because we need to try calling getLowerBound 2 times in a row |
| 4               | getLength       | Decremented (a--) double field lower         | SURVIVED       | Survived because we need to try calling the getLength 2 times in a row                                                          |
| 5               | getLowerBound | Decremented (--a) double field lower|KILLED| Killed because operator is pre-decrement and change to lower is immediate |
| 6               | getLength       | Decremented (a--) double field upper         | SURVIVED       | Survived because we need to try calling the getLength 2 times in a row                                                          |
| 7               | getLength       | Decremented (--a) double field lower         | KILLED       | Killed because operator is pre-decrement and change to lower is immediate                                                          |
| 8               | contains | negated conditional | KILLED | Killed because assertions will detect negation of condition |
| 9               | getCentralValue       | Decremented (a--) double field lower         | SURVIVED       | Survived because we need to try calling getCentralValue 2 times in a row                                                          |
| 10              | getCentralValue       | Decremented (a--) double field upper         | SURVIVED       | Survived because we need to try calling getCentralValue 2 times in a row                                                         |

# Equivalent Mutants

| Class Name       | Equivalent Mutant 1 | Equivalent Mutant 2 | Equivalent Mutant 3 | Equivalent Mutant 4 |
|------------------|---------------------|---------------------|---------------------|---------------------|
| Range            | Range.init: remove call to java/lang/StringBuilder::append at line 92                  | contains: Incremented (a++) double local variable number 1| Range.constrain: Incremented (a++) double local variable number 3 in line 197 | Range.getCentralValue: Replaced Double Division with Multiplication in line 132                   | Range.contains: replaced comparison checked with true in line 144
| DataUtilities    | DataUtilities.clone: Less than to not equal in line 104 | DatatUtilities.equal: Returns integer size value with (x == 0 ? 1: 0) in line 76| DataUtilities.equal: Subsitute 0 with 1 in line 82                   | DataUtilities.CalculateColumnTotal: Subsitute 0.0 with 1.0 in line 125                   |



# Report all the statistics and the mutation score for each test class

<img src="./media/10-PIT-Test-Statistics.png" width=75% height=75%/>

Mutation score formula = ( mutations killed / total mutations ) * 100

**Mutation score for DataUtilities = 46%** <br/>
**Mutation score for Range = 12%** <br/>

# Analysis drawn on the effectiveness of each of the test classes

# A discussion on the effect of equivalent mutants on mutation score accuracy

Manually detected equivalent Mutants
| Mutation Number | Method | Mutation | Killed/Survived | How the Mutation Was Killed or Not by Original Test Suite |
|-----------------|--------|----------|--------|-----------------------------------------------------------|
| 1               |  |  | SURVIVED | Survived the method is 1 line and the effect of the mutant cannot be discovered. |

Process for finding equivalent mutants:


# A discussion of what could have been done to improve the mutation score of the test suites

Test Cases Added for DataUtilities
- `testEqual_NominalCase`
- `testEqual_BothNull`
- `testEqual_TestAisNull`
- `testEqual_TestBisNull`
- `testEqual_DifferentLengths`
- `testEqual_SameLengthDifferentElements`
- `testClone_NominalCase`

**New Mutation Score = 68%**

### Discuss in your report the test cases that you had to add to increase the mutation score, and also how you designed them.
Since methods that weren't tested had no mutation coverage, it made sense to add test cases for these methods which would most definitely increase the overall mutation coverage. 

# Why do we need mutation testing? Advantages and disadvantages of mutation testing
Mutation testing is crucial because it is designed to ensure the quality of the software by conducting unit test. For instance, creating new test cases that wasn't covered or introduces faults increases the mutation coverage. 

Advantages of using mutation testing
- has the ability to detect failures in the code
- Improved Software Quality
- Loopholes in test data can be identified
Disadvantages of using mutaiton testing
- Difficult to implement due to the fact that it might not increase mutation coverage
- Large programs need to be tested against the original test suite

# Explain your SELENUIM test case design process (WILL COME BACK TO THIS LATER)
We split the work to test each gui test cases for 3 different website. We noticed that we have different number of failures for our test cases. 

# Explain the use of assertions and checkpoints

# how did you test each functionaity with different test data

# Discuss advantages and disadvantages of Selenium vs. Sikulix
Advantages of Selenium
- Supports Language and Framework Support
- It's Open Source
- Easy to Implement
- Offers Flexibility
- Resuability
Disadvantages of Selenium
- Has limited support for desktop applications and mobile testing
- Does not support image-based testing
- Limited control over network activities
- Requires built-in reporting capabilities
- Requires latest updates and maintenance to create accurate test cases

Advantages of Sikulix
- Simple to automate windows application
- Allows to check and interact the appearance of the image
- Easily to automate Flash objects
- It's an open source tool
- Allows for quick automation script development

Disadvantage of Sikulix
- Reduces performance when testing image recognition
- GUI Maintenance can impact scripts
- Requires frequent updates to maintain stability
- Requires skill as it relies on image recognition and scripting.
- As you execute scripts over extended durations, it becomes imperative to exercise caution in handling errors effectively.


# How the team work/effort was divided and managed
Me and Karam went through the mutation test and analyze the mutants, coverage, and then reccorded in the report. We added some test cases to improve the coverage by 10%. For the gui testing, we split the work to create test cases in each website. Then we ran all of the test cases to ensure failure and pass.

# Difficulties encountered, challenges overcome, and lessons learned
We were having difficulties with using the Pitest. For this reason, it depends on which java version you're using. I know some of my team members are using Java 1.8 while others are using Java 1.6. Using Selenium is easy to use since you can record all the test cases and run it to see if there are any failues.

# Comments/feedback on the lab itself
